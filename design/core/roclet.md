# Design: roxygen2 roclet for block registration

**Issue:** [#140](https://github.com/BristolMyersSquibb/blockr.core/issues/140)
**Pull Request:** [#142](https://github.com/BristolMyersSquibb/blockr.core/pull/142)

## Problem

`register_core_blocks()` in `R/block-registry.R` hardcodes all metadata (name,
description, category, icon, arguments) for the 10 core blocks in one large function
call. When adding or modifying blocks, developers must update both the constructor file
and this centralized registration function. The metadata lives far from the code it
describes.

## Goal

Declare block registration metadata directly on each constructor via custom roxygen2
tags. A custom roclet generates the data that `register_core_blocks()` consumes. Adding
a new block to the registry becomes a matter of adding tags to the constructor — no
separate file to update.

## Tag design

Five custom tags, placed in the roxygen comment block above a constructor:

```r
#' @block Dataset block
#' @blockDescr Choose a dataset from a package
#' @blockCategory input
#' @blockIcon database
#' @blockParam dataset Selects the dataset to use.
#' @export
new_dataset_block <- function(dataset = character(), package = "datasets", ...) {
```

| Tag | Required | Format | Purpose |
|-----|----------|--------|---------|
| `@block <name>` | yes | single line of text | Triggers registration; value is the human-readable block name (sentence case) |
| `@blockDescr <text>` | yes | single line of text (markdown OK) | Block description |
| `@blockCategory <category>` | yes | single word | One of the suggested categories (input, transform, plot, etc.) |
| `@blockIcon <icon>` | no | single word | Bootstrap icon name. If omitted, derived from `@blockCategory` via `default_icon()`. |
| `@blockParam <name> <description>` | no | `name description` (like `@param`) | Repeatable; names a block argument and its description. Omit entirely for blocks with no arguments. |
| `@blockCtor <name>` | no | single word | Explicit constructor name override. If omitted, derived from the documented object name. |

The constructor function name (e.g. `new_dataset_block`) is derived automatically from
the documented object. The YAML file is keyed by constructor name. Block UIDs are not
part of the roclet — `register_block()` derives them from the class vector as usual.

## Generated output

The roclet writes `inst/registry/blocks.yml`, a YAML file:

```yaml
# Generated by block_registration roclet: do not edit by hand

new_dataset_block:
  name: Dataset block
  description: Choose a dataset from a package
  category: input
  icon: database
  arguments:
    dataset: Selects the dataset to use.

new_subset_block:
  name: Subset block
  description: Row and column subsetting
  category: transform
  icon: funnel
  arguments: {}

...
```

This file is committed to version control (like `NAMESPACE` and `man/*.Rd`). It is
regenerated whenever `devtools::document()` runs.

## `register_package_blocks()` — new exported function

A general-purpose function that reads a YAML registry file and registers all (or a
subset of) blocks from it. Any package that uses the roclet can call this from its
`.onLoad()`.

Note: `register_blocks()` already exists and takes vector arguments directly. This new
function is the YAML-file counterpart.

```r
#' @param path Relative path to a YAML block registry file under `inst/`
#'   (as generated by the `block_registration` roclet). Resolved via
#'   [base::system.file()] using `package`.
#' @param which Character vector of constructor names to register, or `"all"`.
#' @param package Package where constructors are defined and the registry
#'   file lives. Defaults to the calling package.
#' @param overwrite Overwrite existing registry entries.
#' @export
register_package_blocks <- function(path = "registry/blocks.yml",
                                    which = "all", package = pkg_name(),
                                    overwrite = TRUE) {
  file <- system.file(path, package = package, mustWork = TRUE)
  data <- yaml::read_yaml(file)

  if (identical(which, "all")) {
    which <- names(data)
  } else {
    stopifnot(all(which %in% names(data)), anyDuplicated(which) == 0L)
  }

  data <- data[which]

  register_blocks(
    names(data),
    name = chr_xtr(data, "name"),
    description = chr_xtr(data, "description"),
    category = chr_xtr(data, "category"),
    icon = lapply(data, `[[`, "icon"),
    arguments = lapply(data, function(x) {
      args <- x[["arguments"]]
      if (is.null(args) || length(args) == 0L) character() else unlist(args)
    }),
    package = package,
    overwrite = overwrite
  )
}
```

## Updated `register_core_blocks()`

Becomes a thin wrapper. Note that its `which` parameter takes block IDs
(e.g. `"dataset_block"`) for backwards compatibility, so it maps these to constructor
names before delegating:

```r
register_core_blocks <- function(which = blockr_option("core_blocks", "all")) {
  if (!identical(which, "all")) {
    which <- paste0("new_", which)
  }
  register_package_blocks(which = which)
}
```

Signature and semantics stay the same. Existing callers (including `.onLoad()` and
tests) are unaffected.

## Roclet implementation

A single new file `R/block-roclet.R` contains everything:

### Constructor (exported)

```r
#' @export
block_registration_roclet <- function() {
  roxygen2::roclet("block_registration")
}
```

### Tag parsers (S3 methods, registered automatically)

```r
roxy_tag_parse.roxy_tag_block          <- function(x) roxygen2::tag_value(x)
roxy_tag_parse.roxy_tag_blockDescr    <- function(x) roxygen2::tag_markdown(x)
roxy_tag_parse.roxy_tag_blockCategory <- function(x) roxygen2::tag_value(x)
roxy_tag_parse.roxy_tag_blockIcon     <- function(x) roxygen2::tag_value(x)
roxy_tag_parse.roxy_tag_blockParam    <- function(x) roxygen2::tag_name_description(x)
roxy_tag_parse.roxy_tag_blockCtor     <- function(x) roxygen2::tag_value(x)
```

### `roclet_process()`

Iterates over all roxygen blocks. For each block that has a `@block` tag:

1. Reads the constructor name from `@blockCtor` if present, otherwise from the block
   object (likely `block$object$alias` or `block$object$topic` — the exact field needs
   to be confirmed against the roxygen2 version in use; fall back to parsing
   `block$call` if needed)
2. Validates that required companion tags (`@blockDescr`, `@blockCategory`) are
   present. Tag-level parse methods only see individual tags, so
   cross-tag validation must happen here in `roclet_process()` where the full block is
   available. Missing tags are reported using `roxy_tag_warning()` or `cli::cli_abort()`
   with the source file/line from the `@block` tag.
3. Collects `@blockDescr`, `@blockCategory`, `@blockIcon`, `@blockParam` values
4. Returns a named list of block metadata (keyed by constructor name)

### `roclet_output()`

Writes the list from `roclet_process()` as YAML to `inst/registry/blocks.yml`,
prepended with a "do not edit" comment.

### `roclet_clean()`

Removes `inst/registry/blocks.yml` if it has the generated header.

## DESCRIPTION changes

```
Roxygen: list(
  markdown = TRUE,
  packages = c("roxy.shinylive"),
  roclets = c("collate", "rd", "namespace",
              "blockr.core::block_registration_roclet")
)
```

The `roclets` entry adds the custom roclet alongside the standard ones.
No `packages` change needed — `devtools::document()` runs `load_all()` first,
making tag parsers and the roclet constructor available.

`yaml` is added to `Imports` (since `register_package_blocks()` calls
`yaml::read_yaml()` at runtime).

`R/block-roclet.R` is added to the `Collate:` field.

## Files summary

| Action | File | What changes |
|--------|------|-------------|
| create | `R/block-roclet.R` | Roclet constructor, tag parsers, process/output/clean methods |
| create | `inst/registry/blocks.yml` | Initial generated YAML (bootstrap; regenerated by roclet) |
| modify | `R/block-registry.R` | Replace `register_core_blocks()` body with YAML-driven version |
| modify | `R/data-dataset.R` | Add `@block`, `@blockDescr`, `@blockCategory`, `@blockIcon`, `@blockParam` |
| modify | `R/transform-subset.R` | Add `@block`, `@blockDescr`, `@blockCategory`, `@blockIcon` |
| modify | `R/transform-merge.R` | Add `@block`, `@blockDescr`, `@blockCategory`, `@blockIcon` |
| modify | `R/transform-rbind.R` | Add `@block`, `@blockDescr`, `@blockCategory`, `@blockIcon` |
| modify | `R/plot-scatter.R` | Add `@block`, `@blockDescr`, `@blockCategory`, `@blockIcon` |
| modify | `R/file-upload.R` | Add `@block`, `@blockDescr`, `@blockCategory`, `@blockIcon` |
| modify | `R/file-browser.R` | Add `@block`, `@blockDescr`, `@blockCategory`, `@blockIcon` |
| modify | `R/parser-csv.R` | Add `@block`, `@blockDescr`, `@blockCategory`, `@blockIcon` |
| modify | `R/transform-head.R` | Add `@block`, `@blockDescr`, `@blockCategory`, `@blockIcon` |
| modify | `R/text-glue.R` | Add `@block`, `@blockDescr`, `@blockCategory`, `@blockIcon` |
| modify | `DESCRIPTION` | Update `Roxygen:` field; add `yaml` to `Imports`; update `Collate:` |

## Extension packages

The same roclet works for downstream packages (e.g. `blockr.foobar`). They would:

1. Have `blockr.core` in `Imports` (as they already do)
2. Add `blockr.core::block_registration_roclet` to their `Roxygen: list(roclets = ...)`
3. Annotate their own constructors with `@block` tags
4. Get their own `inst/registry/blocks.yml` generated
5. Call `register_package_blocks()` from their `.onLoad()`:

```r
.onLoad <- function(libname, pkgname) {
  blockr.core::register_package_blocks(package = pkgname)
}
```

## Bootstrapping

The generated YAML is committed to version control. On first clone:

1. `devtools::install()` installs the package (generated YAML already present)
2. `devtools::document()` regenerates the YAML using the roclet

This is the same pattern as `NAMESPACE` — generated by roxygen2, committed to the repo.

## Implementation notes

Things to keep an eye on during implementation:

- **roxygen2 in Suggests**: `R/block-roclet.R` references `roxygen2::tag_value()`,
  `roxygen2::roclet()`, etc. in function bodies. These are only called during
  `devtools::document()`, never at runtime, but R CMD check will flag the `roxygen2::`
  references unless we add it to `Suggests`. Currently it is not listed in DESCRIPTION
  at all.

- **NULL icons through `register_blocks()`**: When `@blockIcon` is omitted, `NULL` is
  passed through the `arg_processor` + `Map` machinery in `register_blocks()`. This is
  an untested path since current callers always pass strings. Worth a sanity check.

- **yaml in Imports**: Must be declared explicitly since `register_package_blocks()`
  calls `yaml::read_yaml()` at runtime. It is already a transitive dependency, so no
  new install burden.

## Verification

1. `devtools::install()` then `devtools::document()` — should regenerate
   `inst/registry/blocks.yml` matching the bootstrap version
2. `devtools::load_all()` then `list_blocks()` — should return all 10 core blocks
3. `devtools::test()` — existing `test-block-registry.R` tests pass unchanged
4. `registry_metadata()` returns identical results to before
